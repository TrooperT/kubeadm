# TrooperT/kubeadm
TrooperT/kubeadm is intended as part a solution to a problem I encountered while working on a baremetal K8s cluster setup utilizing Talos linux and Kube-vip

Vision:
Design an HA Kubernetes control plane using Talos Linux and Kube-VIP where the VIP:
* is **NOT** in the same network space as the nodes' local IPS
* is **NOT** utilizing Talos' etcd-based VIP functionality
Problem:
Choosing to run kube-vip as a static pod on each controlplane node has a few limitations:
* static pod specs **cannont** refer to API objects (e.g., ServiceAccount, ConfigMap, Secret, etc).
* kube-vip expects to have kubernetes API access
  * The static pods manifests generated by kube-vip resolve this by host-path mounting `/etc/kuberenetes/admin.conf` into the container
    * Talos Linux does not have this file, leaving us to generate one on our own and emptyDir mount it into the kube-vip container
  * The daemonset manifest generated by kube-vip has its own drawbacks:
    * Daemonset is k8s object so is modifiable by the cluster itself, violating the separation of concerns regarding Infrastructure and operations
    * would be modifiable from with-in the cluster, potentially bringing down the VIP due to mis-configuration
    * would potentially require Talos be configured with `allowSchedulingOnControlPlanes`

Solution:
TrooperT/kubeadm uses alpine:latest with kubeadm added to generate an admin.conf file with CN=kubevip from 3 environment variables: `$KUBEADM_B64, $KUBECACRT_B64, $KUBECAKEY_B64`
It is intended as an init container to create the admin.conf expected by kube-vip


Outlook:
I'm 100% positive there is an objectively better way to accomplish the goal, probably with FRR as a static pod or similar. This works for now, abeit in a rather insecure fashion
